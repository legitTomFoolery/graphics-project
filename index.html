<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>Three.js 101</title>
    <!--  Simple reset to delete the margins  -->
    <style>
        body {
            margin: 0;
        }

        canvas {
            width: 100%;
            height: 100%
        }
    </style>
    <!--  Three.js CDN  -->

    <script type="importmap">
        {
            "imports": {
                "three": "./three.js-master/build/three.module.js",
                "GLTFLoader": "./three.js-master/examples/jsm/loaders/GLTFLoader.js"
            }
        }
    </script>

    <script src=></script>
    <script type="module" src="./three.js-master/examples/jsm/loaders/GLTFLoader.js"></script>
    <script src="./PapaParse-5.0.2/papaparse.js"></script>
</head>

<body>
    <audio controls loop>
        <source src="./audio/Gwent_Music.mp3" type="audio/mpeg">
        Your browser does not support he audio element
    </audio>
    <!--  Our code  -->
    <script type="module">

        const response = await fetch('cards1.csv');
        const text = await response.text();

        let cardData;
        var data = Papa.parse(text, {
            header: true,
            complete: function (results) {
                cardData = results.data;
            }
        })

        var snd;

        cardData.forEach(function myfunc(card) {
            card['leader'] = parseInt(card['leader']);
            card['horn'] = parseInt(card['horn']);
            card['decoy'] = parseInt(card['decoy']);
            card['weather'] = parseInt(card['weather']);
            card['melee'] = parseInt(card['melee']);
            card['ranged'] = parseInt(card['ranged']);
            card['siege'] = parseInt(card['siege']);
            card['strength'] = parseInt(card['strength']);
            card['hero'] = parseInt(card['hero']);
            snd = new Audio(card['audio'])
            card['audio'] = snd;

        });

        import * as THREE from './three.js-master/build/three.module.js';
        import { GLTFLoader } from './three.js-master/examples/jsm/loaders/GLTFLoader.js';
        
       

        //
        /** @namespace */
        var THREEx = THREEx || {};

        makeTHREEx();

        let container;

        let camera, scene, renderer;

        let group;

        let targetRotation = 0;
        let targetRotationOnPointerDown = 0;

        let pointerX = 0;
        let pointerXOnPointerDown = 0;

        let windowHalfX = window.innerWidth / 2;

        let mesh;

        let vis = true;

        let selected = 0;

        let melee = [];
        let ranged = [];
        let siege = []

        init();
        animate();

        function init() {

            container = document.createElement('div');
            document.body.appendChild(container);

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f0f0);

            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 1000);
            camera.position.set(0, 150, 500);
            scene.add(camera);

            const light = new THREE.PointLight(0xffffff, 1.1);
            camera.add(light);

            group = new THREE.Group();
            group.position.y = 50;
            scene.add(group);

            let extrudeSettings;

            const loader = new THREE.TextureLoader();
            loader.crossOrigin = "anonymous";

            const testShape = new THREE.Shape();
            roundedRect(testShape, 0, 0, 135, 220, 10);
            extrudeSettings = { depth: 0, bevelEnabled: false, bevelSegments: 2, steps: 2, bevelSize: 1, bevelThickness: 1 };

            let texture;

            texture = loader.load("textures/sparkimage.png");
            texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(0.0062, 0.004);
            addShape(testShape, extrudeSettings, 0x008000, texture, -300, 0, 100, 0, 0, 0, 1);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            container.appendChild(renderer.domElement);

            container.style.touchAction = 'none';

            let domEvents = new THREEx.DomEvents(camera, renderer.domElement)

            // MELEE ROW
            const rowShape = new THREE.Shape();
            roundedRect(rowShape, 220, 260, 320, 90, 10);
            extrudeSettings = { depth: 4, bevelEnabled: false, bevelSegments: 2, steps: 2, bevelSize: 1, bevelThickness: 1 };

            addShape(rowShape, extrudeSettings, 0x008000, null, -300, 0, 0, 0, 0, 0, 1);

            console.log(mesh)
            mesh.material.color = {"r": 232/255, "g": 218/255, "b": 125/255};
            mesh.material.opacity = 0.0;

            domEvents.addEventListener(mesh, "mouseover", function (event) {
                // mesh.material.opacity = 0.25;
            });


            domEvents.addEventListener(mesh, "click", function (event) {
                if (selected && !melee.includes(selected) && selected["melee"]) {
                    selected["mesh"].scale.set(0.5, 0.5, 0.5)
                    melee.push(selected);
                    melee.sort(function (a, b) {
                        return -(b["strength"] - a["strength"]);
                    })
                    let place = 0;
                    let start = -50 * melee.length + 90;
                    if (melee.length >= 8)
                        start = -270;
                    if (melee.length == 10)
                        start = -280;
                    for (place = 0; place < melee.length; place++) {
                        melee[place]["mesh"].position.z = place * 2 - 60;
                        melee[place]["mesh"].position.y = 250;
                        if (melee.length < 8)
                            melee[place]["mesh"].position.x = start + place * (100);
                        else
                            melee[place]["mesh"].position.x = start + place * (700 / melee.length);
                    }
                    selected['audio'].play();
                    selected['audio'].currentTime = 0;
                    selected = 0;
                }
            });

            //RANGED ROW
            roundedRect(rowShape, 220, 162, 320, 90, 10);
            addShape(rowShape, extrudeSettings, 0x008000, null, -300, 0, 0, 0, 0, 0, 1);
            mesh.material.color = {"r": 232/255, "g": 218/255, "b": 125/255};
            mesh.material.opacity = 0.0;

            domEvents.addEventListener(mesh, "click", function (event) {
                if (selected && !ranged.includes(selected) && selected["ranged"]) {
                    selected["mesh"].scale.set(0.5, 0.5, 0.5)
                    ranged.push(selected);
                    ranged.sort(function (a, b) {
                        return -(b["strength"] - a["strength"]);
                    })
                    let place = 0;
                    let start = -50 * ranged.length + 90;
                    if (ranged.length >= 8)
                        start = -270;
                    if (ranged.length == 10)
                        start = -280;
                    for (place = 0; place < ranged.length; place++) {
                        ranged[place]["mesh"].position.z = place * 2 - 60;
                        ranged[place]["mesh"].position.y = 150;
                        if (ranged.length < 8)
                            ranged[place]["mesh"].position.x = start + place * (100);
                        else
                            ranged[place]["mesh"].position.x = start + place * (700 / ranged.length);
                    }
                    selected['audio'].play();
                    selected['audio'].currentTime = 0;
                    selected = 0;
                }
            });

            //SEIGE ROW
            roundedRect(rowShape, 220, 65, 320, 90, 10);
            addShape(rowShape, extrudeSettings, 0x008000, null, -300, 0, 0, 0, 0, 0, 1);
            mesh.material.color = {"r": 232/255, "g": 218/255, "b": 125/255};
            mesh.material.opacity = 0.0;

            domEvents.addEventListener(mesh, "click", function (event) {
                if (selected && !siege.includes(selected) && selected["siege"]) {
                    selected["mesh"].scale.set(0.5, 0.5, 0.5)
                    siege.push(selected);
                    siege.sort(function (a, b) {
                        return -(b["strength"] - a["strength"]);
                    })
                    let place = 0;
                    let start = -50 * siege.length + 90;
                    if (siege.length >= 8)
                        start = -270;
                    if (siege.length == 10)
                        start = -280;
                    for (place = 0; place < siege.length; place++) {
                        siege[place]["mesh"].position.z = place * 2 - 60;
                        siege[place]["mesh"].position.y = 55;
                        if (siege.length < 8)
                            siege[place]["mesh"].position.x = start + place * (100);
                        else
                            siege[place]["mesh"].position.x = start + place * (700 / siege.length);
                    }
                    selected['audio'].play();
                    selected['audio'].currentTime = 0;
                    selected = 0;
                }
            });

            ///////
            let x = 0;
            let y = -160;
            let z = 10;

            let meshes = [];
            let topMeshes = [];

            cardData.forEach(testDisplay);
            function testDisplay(d) {
                if (!d["leader"] && d["strength"] > 5
                    && x / 1000 < 1) {
                    const cardShape = new THREE.Shape();
                    roundedRect(cardShape, 0, 0, 115, 200, 10);
                    extrudeSettings = { depth: 4, bevelEnabled: false, bevelSegments: 2, steps: 2, bevelSize: 1, bevelThickness: 1 };

                    texture = loader.load(d["image"]);

                    // it's necessary to apply these settings in order to correctly display the texture on a shape geometry

                    texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
                    texture.repeat.set(0.0085, 0.005);

                    addShape(cardShape, extrudeSettings, 0x008000, texture, x % 1000 - 500, y, z, 0, 0, 0, .9);

                    meshes.push(mesh);
                    let currentMesh = meshes.length - 1;

                    d["mesh"] = mesh;

                    domEvents.addEventListener(meshes[currentMesh], "mouseover", function (event) {
                        //ADD EVENT
                        if (!selected && !melee.includes(d) && !ranged.includes(d) && !siege.includes(d)) {
                            d["mesh"].position.z += 10;
                            d["mesh"].position.y += 20;
                        }
                    }, false);
                    domEvents.addEventListener(meshes[currentMesh], "mouseout", function (event) {
                        //ADD EVENT
                        if (!selected && !melee.includes(d) && !ranged.includes(d) && !siege.includes(d)) {
                            d["mesh"].position.z -= 10;
                            d["mesh"].position.y -= 20;
                        }
                    }, false);
                    domEvents.addEventListener(meshes[currentMesh], "click", function (event) {
                        if (!selected && !melee.includes(d) && !ranged.includes(d) && !siege.includes(d)) {
                            selected = d;
                            setTimeout(function() {
                                // console.log('hi');
                                // var image = new Image();
                                // image.src = './textures/ballista.png';
                                // image.crossOrigin = 'anonymous';
                                // selected["mesh"].material.map.source.data = image;
                                // selected["mesh"].material.map.needsUpdate = true;
                            }, 1);
                        } else if (selected == d) {
                            selected = 0;
                        }
                    });


                    // it's necessary to apply these settings in order to correctly display the texture on a shape geometry


                    x += 100;
                    if (x % 1000 == 0 && x != 0) {
                        y -= 100;
                        z = 0
                    }
                    z += 2;
                }
            }
            

            texture = loader.load("textures/wood.jpg");
            texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(0.0012, 0.005);

            const model_loader = new GLTFLoader();
            model_loader.load('./models/new_gwent_board.glb', function(gltf) {
                var model = gltf.scene;
                model.position.set(-200.0, 0.0, -100.0)
                model.rotation.set(1.55, 0.0, 0.0);
                model.scale.set(0.95, 0.95, 0.95);
                console.log(model)
                scene.add(model);}, 
                
                undefined, 
                
                function ( error ) {
                    console.error( error );
            });

        }

        

        function roundedRect(ctx, x, y, width, height, radius) {

            ctx.moveTo(x, y + radius);
            ctx.lineTo(x, y + height - radius);
            ctx.quadraticCurveTo(x, y + height, x + radius, y + height);
            ctx.lineTo(x + width - radius, y + height);
            ctx.quadraticCurveTo(x + width, y + height, x + width, y + height - radius);
            ctx.lineTo(x + width, y + radius);
            ctx.quadraticCurveTo(x + width, y, x + width - radius, y);
            ctx.lineTo(x + radius, y);
            ctx.quadraticCurveTo(x, y, x, y + radius);

        }

        function addShape(shape, extrudeSettings, color, texture, x, y, z, rx, ry, rz, s) {

            // console.log(texture);
            const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);

            mesh = new THREE.Mesh(geometry, new THREE.MeshPhongMaterial({ map: texture, transparent: true }));

            mesh.position.set(x, y, z - 75);
            mesh.rotation.set(rx, ry, rz);
            mesh.scale.set(s, s, s);
            group.add(mesh);
        }

        function animate() {

            requestAnimationFrame(animate);

            render();
        }

        function render() {

            group.rotation.y += (targetRotation - group.rotation.y) * 0.05;
            renderer.render(scene, camera);
            //mesh.visible = vis;

        }

        renderer.domElement.addEventListener("click", onclick, true);

        /////
        function makeTHREEx() {
            // # Constructor
            THREEx.DomEvents = function (camera, domElement) {
                this._camera = camera || null;
                this._domElement = domElement || document;
                this._raycaster = new THREE.Raycaster();
                this._selected = null;
                this._boundObjs = {};
                // Bind dom event for mouse and touch
                var _this = this;

                this._$onClick = function () { _this._onClick.apply(_this, arguments); };
                this._$onDblClick = function () { _this._onDblClick.apply(_this, arguments); };
                this._$onMouseMove = function () { _this._onMouseMove.apply(_this, arguments); };
                this._$onMouseDown = function () { _this._onMouseDown.apply(_this, arguments); };
                this._$onMouseUp = function () { _this._onMouseUp.apply(_this, arguments); };
                this._$onTouchMove = function () { _this._onTouchMove.apply(_this, arguments); };
                this._$onTouchStart = function () { _this._onTouchStart.apply(_this, arguments); };
                this._$onTouchEnd = function () { _this._onTouchEnd.apply(_this, arguments); };
                this._$onContextmenu = function () { _this._onContextmenu.apply(_this, arguments); };
                this._domElement.addEventListener('click', this._$onClick, false);
                this._domElement.addEventListener('dblclick', this._$onDblClick, false);
                this._domElement.addEventListener('mousemove', this._$onMouseMove, false);
                this._domElement.addEventListener('mousedown', this._$onMouseDown, false);
                this._domElement.addEventListener('mouseup', this._$onMouseUp, false);
                this._domElement.addEventListener('touchmove', this._$onTouchMove, false);
                this._domElement.addEventListener('touchstart', this._$onTouchStart, false);
                this._domElement.addEventListener('touchend', this._$onTouchEnd, false);
                this._domElement.addEventListener('contextmenu', this._$onContextmenu, false);

            }

            // # Destructor
            THREEx.DomEvents.prototype.destroy = function () {
                // unBind dom event for mouse and touch
                this._domElement.removeEventListener('click', this._$onClick, false);
                this._domElement.removeEventListener('dblclick', this._$onDblClick, false);
                this._domElement.removeEventListener('mousemove', this._$onMouseMove, false);
                this._domElement.removeEventListener('mousedown', this._$onMouseDown, false);
                this._domElement.removeEventListener('mouseup', this._$onMouseUp, false);
                this._domElement.removeEventListener('touchmove', this._$onTouchMove, false);
                this._domElement.removeEventListener('touchstart', this._$onTouchStart, false);
                this._domElement.removeEventListener('touchend', this._$onTouchEnd, false);
                this._domElement.removeEventListener('contextmenu', this._$onContextmenu, false);
            }

            THREEx.DomEvents.eventNames = [
                "click",
                "dblclick",
                "mouseover",
                "mouseout",
                "mousemove",
                "mousedown",
                "mouseup",
                "contextmenu",
                "touchstart",
                "touchend"
            ];

            THREEx.DomEvents.prototype._getRelativeMouseXY = function (domEvent) {
                var element = domEvent.target || domEvent.srcElement;
                if (element.nodeType === 3) {
                    element = element.parentNode; // Safari fix -- see http://www.quirksmode.org/js/events_properties.html
                }

                //get the real position of an element relative to the page starting point (0, 0)
                //credits go to brainjam on answering http://stackoverflow.com/questions/5755312/getting-mouse-position-relative-to-content-area-of-an-element
                var elPosition = { x: 0, y: 0 };
                var tmpElement = element;
                //store padding
                var style = getComputedStyle(tmpElement, null);
                elPosition.y += parseInt(style.getPropertyValue("padding-top"), 10);
                elPosition.x += parseInt(style.getPropertyValue("padding-left"), 10);
                //add positions
                do {
                    elPosition.x += tmpElement.offsetLeft;
                    elPosition.y += tmpElement.offsetTop;
                    style = getComputedStyle(tmpElement, null);

                    elPosition.x += parseInt(style.getPropertyValue("border-left-width"), 10);
                    elPosition.y += parseInt(style.getPropertyValue("border-top-width"), 10);
                } while (tmpElement = tmpElement.offsetParent);

                var elDimension = {
                    width: (element === window) ? window.innerWidth : element.offsetWidth,
                    height: (element === window) ? window.innerHeight : element.offsetHeight
                };

                return {
                    x: +((domEvent.pageX - elPosition.x) / elDimension.width) * 2 - 1,
                    y: -((domEvent.pageY - elPosition.y) / elDimension.height) * 2 + 1
                };
            };


            /********************************************************************************/
            /*		domevent context						*/
            /********************************************************************************/

            // handle domevent context in object3d instance

            THREEx.DomEvents.prototype._objectCtxInit = function (object3d) {
                object3d._3xDomEvent = {};
            }
            THREEx.DomEvents.prototype._objectCtxDeinit = function (object3d) {
                delete object3d._3xDomEvent;
            }
            THREEx.DomEvents.prototype._objectCtxIsInit = function (object3d) {
                return object3d._3xDomEvent ? true : false;
            }
            THREEx.DomEvents.prototype._objectCtxGet = function (object3d) {
                return object3d._3xDomEvent;
            }

            /********************************************************************************/
            /*										*/
            /********************************************************************************/

            /**
             * Getter/Setter for camera
            */
            THREEx.DomEvents.prototype.camera = function (value) {
                if (value) this._camera = value;
                return this._camera;
            }

            THREEx.DomEvents.prototype.bind = function (object3d, eventName, callback, useCapture) {
                console.assert(THREEx.DomEvents.eventNames.indexOf(eventName) !== -1, "not available events:" + eventName);

                if (!this._objectCtxIsInit(object3d)) this._objectCtxInit(object3d);
                var objectCtx = this._objectCtxGet(object3d);
                if (!objectCtx[eventName + 'Handlers']) objectCtx[eventName + 'Handlers'] = [];

                objectCtx[eventName + 'Handlers'].push({
                    callback: callback,
                    useCapture: useCapture
                });

                // add this object in this._boundObjs
                if (this._boundObjs[eventName] === undefined) {
                    this._boundObjs[eventName] = [];
                }
                this._boundObjs[eventName].push(object3d);
            }
            THREEx.DomEvents.prototype.addEventListener = THREEx.DomEvents.prototype.bind

            THREEx.DomEvents.prototype.unbind = function (object3d, eventName, callback, useCapture) {
                console.assert(THREEx.DomEvents.eventNames.indexOf(eventName) !== -1, "not available events:" + eventName);

                if (!this._objectCtxIsInit(object3d)) this._objectCtxInit(object3d);

                var objectCtx = this._objectCtxGet(object3d);
                if (!objectCtx[eventName + 'Handlers']) objectCtx[eventName + 'Handlers'] = [];

                var handlers = objectCtx[eventName + 'Handlers'];
                for (var i = 0; i < handlers.length; i++) {
                    var handler = handlers[i];
                    if (callback != handler.callback) continue;
                    if (useCapture != handler.useCapture) continue;
                    handlers.splice(i, 1)
                    break;
                }
                // from this object from this._boundObjs
                var index = this._boundObjs[eventName].indexOf(object3d);
                console.assert(index !== -1);
                this._boundObjs[eventName].splice(index, 1);
            }
            THREEx.DomEvents.prototype.removeEventListener = THREEx.DomEvents.prototype.unbind

            THREEx.DomEvents.prototype._bound = function (eventName, object3d) {
                var objectCtx = this._objectCtxGet(object3d);
                if (!objectCtx) return false;
                return objectCtx[eventName + 'Handlers'] ? true : false;
            }

            /********************************************************************************/
            /*		onMove								*/
            /********************************************************************************/

            // # handle mousemove kind of events

            THREEx.DomEvents.prototype._onMove = function (eventName, mouseX, mouseY, origDomEvent) {
                //console.log('eventName', eventName, 'boundObjs', this._boundObjs[eventName])
                // get objects bound to this event
                var boundObjs = this._boundObjs[eventName];
                if (boundObjs === undefined || boundObjs.length === 0) return;
                // compute the intersection
                var vector = new THREE.Vector2();

                // update the picking ray with the camera and mouse position
                vector.set(mouseX, mouseY);
                this._raycaster.setFromCamera(vector, this._camera);

                var intersects = this._raycaster.intersectObjects(boundObjs);

                var oldSelected = this._selected;

                if (intersects.length > 0) {
                    var notifyOver, notifyOut, notifyMove;
                    var intersect = intersects[0];
                    var newSelected = intersect.object;
                    this._selected = newSelected;
                    // if newSelected bound mousemove, notify it
                    notifyMove = this._bound('mousemove', newSelected);

                    if (oldSelected != newSelected) {
                        // if newSelected bound mouseenter, notify it
                        notifyOver = this._bound('mouseover', newSelected);
                        // if there is a oldSelect and oldSelected bound mouseleave, notify it
                        notifyOut = oldSelected && this._bound('mouseout', oldSelected);
                    }
                } else {
                    // if there is a oldSelect and oldSelected bound mouseleave, notify it
                    notifyOut = oldSelected && this._bound('mouseout', oldSelected);
                    this._selected = null;
                }


                // notify mouseMove - done at the end with a copy of the list to allow callback to remove handlers
                notifyMove && this._notify('mousemove', newSelected, origDomEvent, intersect);
                // notify mouseEnter - done at the end with a copy of the list to allow callback to remove handlers
                notifyOver && this._notify('mouseover', newSelected, origDomEvent, intersect);
                // notify mouseLeave - done at the end with a copy of the list to allow callback to remove handlers
                notifyOut && this._notify('mouseout', oldSelected, origDomEvent, intersect);
            }


            /********************************************************************************/
            /*		onEvent								*/
            /********************************************************************************/

            // # handle click kind of events

            THREEx.DomEvents.prototype._onEvent = function (eventName, mouseX, mouseY, origDomEvent) {
                //console.log('eventName', eventName, 'boundObjs', this._boundObjs[eventName])
                // get objects bound to this event
                var boundObjs = this._boundObjs[eventName];
                if (boundObjs === undefined || boundObjs.length === 0) return;
                // compute the intersection
                var vector = new THREE.Vector2();

                // update the picking ray with the camera and mouse position
                vector.set(mouseX, mouseY);
                this._raycaster.setFromCamera(vector, this._camera);

                var intersects = this._raycaster.intersectObjects(boundObjs, true);
                // if there are no intersections, return now
                if (intersects.length === 0) return;

                // init some variables
                var intersect = intersects[0];
                var object3d = intersect.object;
                var objectCtx = this._objectCtxGet(object3d);
                var objectParent = object3d.parent;

                while (typeof (objectCtx) == 'undefined' && objectParent) {
                    objectCtx = this._objectCtxGet(objectParent);
                    objectParent = objectParent.parent;
                }
                if (!objectCtx) return;

                // notify handlers
                this._notify(eventName, object3d, origDomEvent, intersect);
            }

            THREEx.DomEvents.prototype._notify = function (eventName, object3d, origDomEvent, intersect) {
                var objectCtx = this._objectCtxGet(object3d);
                var handlers = objectCtx ? objectCtx[eventName + 'Handlers'] : null;

                // parameter check
                console.assert(arguments.length === 4)

                // do bubbling
                if (!objectCtx || !handlers || handlers.length === 0) {
                    object3d.parent && this._notify(eventName, object3d.parent, origDomEvent, intersect);
                    return;
                }

                // notify all handlers
                var handlers = objectCtx[eventName + 'Handlers'];
                for (var i = 0; i < handlers.length; i++) {
                    var handler = handlers[i];
                    var toPropagate = true;
                    handler.callback({
                        type: eventName,
                        target: object3d,
                        origDomEvent: origDomEvent,
                        intersect: intersect,
                        stopPropagation: function () {
                            toPropagate = false;
                        }
                    });
                    if (!toPropagate) continue;
                    // do bubbling
                    if (handler.useCapture === false) {
                        object3d.parent && this._notify(eventName, object3d.parent, origDomEvent, intersect);
                    }
                }
            }

            /********************************************************************************/
            /*		handle mouse events						*/
            /********************************************************************************/
            // # handle mouse events

            THREEx.DomEvents.prototype._onMouseDown = function (event) { return this._onMouseEvent('mousedown', event); }
            THREEx.DomEvents.prototype._onMouseUp = function (event) { return this._onMouseEvent('mouseup', event); }


            THREEx.DomEvents.prototype._onMouseEvent = function (eventName, domEvent) {
                var mouseCoords = this._getRelativeMouseXY(domEvent);
                this._onEvent(eventName, mouseCoords.x, mouseCoords.y, domEvent);
            }

            THREEx.DomEvents.prototype._onMouseMove = function (domEvent) {
                var mouseCoords = this._getRelativeMouseXY(domEvent);
                this._onMove('mousemove', mouseCoords.x, mouseCoords.y, domEvent);
                this._onMove('mouseover', mouseCoords.x, mouseCoords.y, domEvent);
                this._onMove('mouseout', mouseCoords.x, mouseCoords.y, domEvent);
            }

            THREEx.DomEvents.prototype._onClick = function (event) {
                // TODO handle touch ?
                this._onMouseEvent('click', event);
            }
            THREEx.DomEvents.prototype._onDblClick = function (event) {
                // TODO handle touch ?
                this._onMouseEvent('dblclick', event);
            }

            THREEx.DomEvents.prototype._onContextmenu = function (event) {
                //TODO don't have a clue about how this should work with touch..
                this._onMouseEvent('contextmenu', event);
            }

            /********************************************************************************/
            /*		handle touch events						*/
            /********************************************************************************/
            // # handle touch events


            THREEx.DomEvents.prototype._onTouchStart = function (event) { return this._onTouchEvent('touchstart', event); }
            THREEx.DomEvents.prototype._onTouchEnd = function (event) { return this._onTouchEvent('touchend', event); }

            THREEx.DomEvents.prototype._onTouchMove = function (domEvent) {
                if (domEvent.touches.length != 1) return undefined;

                domEvent.preventDefault();

                var mouseX = +(domEvent.touches[0].pageX / window.innerWidth) * 2 - 1;
                var mouseY = -(domEvent.touches[0].pageY / window.innerHeight) * 2 + 1;
                this._onMove('mousemove', mouseX, mouseY, domEvent);
                this._onMove('mouseover', mouseX, mouseY, domEvent);
                this._onMove('mouseout', mouseX, mouseY, domEvent);
            }

            THREEx.DomEvents.prototype._onTouchEvent = function (eventName, domEvent) {
                if (domEvent.touches.length != 1) return undefined;

                domEvent.preventDefault();

                var mouseX = +(domEvent.touches[0].pageX / window.innerWidth) * 2 - 1;
                var mouseY = -(domEvent.touches[0].pageY / window.innerHeight) * 2 + 1;
                this._onEvent(eventName, mouseX, mouseY, domEvent);
            }
            //
        }



        /////
    </script>
    <p></p>
</body>

</html>