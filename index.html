<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>Three.js 101</title>
    <!--  Simple reset to delete the margins  -->
    <style>
        body {
            margin: 0;
        }

        canvas {
            width: 100%;
            height: 100%
        }
    </style>
    <!--  Three.js CDN  -->

    <script type="importmap">
        {
            "imports": {
                "three": "./three.js-master/build/three.module.js",
                "GLTFLoader": "./three.js-master/examples/jsm/loaders/GLTFLoader.js"
            }
        }
    </script>

    <script src=></script>
    <script type="module" src="./three.js-master/examples/jsm/loaders/GLTFLoader.js"></script>
    <script src="./PapaParse-5.0.2/papaparse.js"></script>
</head>

<body>
    <audio controls loop>
        <source src="./audio/Gwent_Music.mp3" type="audio/mpeg">
        Your browser does not support he audio element
    </audio>
    <!--  Our code  -->
    <script type="module">

        const response = await fetch('cards1.csv');
        const text = await response.text();

        let cardData;
        var data = Papa.parse(text, {
            header: true,
            complete: function (results) {
                cardData = results.data;
            }
        })

        var snd;

        cardData.forEach(function myfunc(card) {
            card['leader'] = parseInt(card['leader']);
            card['horn'] = parseInt(card['horn']);
            card['decoy'] = parseInt(card['decoy']);
            card['weather'] = parseInt(card['weather']);
            card['melee'] = parseInt(card['melee']);
            card['ranged'] = parseInt(card['ranged']);
            card['siege'] = parseInt(card['siege']);
            card['strength'] = parseInt(card['strength']);
            card['hero'] = parseInt(card['hero']);
            if (parseInt(card['audio']) != 0) {
                snd = new Audio(card['audio'])
                card['audio'] = snd;
            }

        });

        import * as THREE from './three.js-master/build/three.module.js';
        import { GLTFLoader } from './three.js-master/examples/jsm/loaders/GLTFLoader.js';



        //
        /** @namespace */
        var THREEx = THREEx || {};

        makeTHREEx();

        let container;

        let camera, scene, renderer;

        let group;

        let targetRotation = 0;
        let targetRotationOnPointerDown = 0;

        let pointerX = 0;
        let pointerXOnPointerDown = 0;

        let windowHalfX = window.innerWidth / 2;

        let mesh;

        let vis = true;

        let selected = 0;

        let melee = [];
        let ranged = [];
        let siege = []

        let extrudeSettings;
        let texture;

        const rowShape = new THREE.Shape();

        let rowOpacity = 0.0;
        let rowWidth = 380;
        let rowHeight = 72;
        let rowSpacing = 77;
        let rowX = 230;
        let rowY = 210;
        let maxCards = 6;

        let meleeMesh;
        let rangedMesh;
        let siegeMesh;

        //let rowZ;

        let cardWidth = 90;
        let cardHeight = 120;
        let cardTextureX = 0.011;
        let cardTextureY = 0.00815;
        let x = 0;
        let y = -160;
        let z = -60;
        let meleeCardY = 217;
        let cardVertSpacing = 76;

        let meshes = [];
        let topMeshes = [];

        let handCards = [];
        let handCardX = 0;

        let meleeCards = [];
        let rangedCards = [];
        let siegeCards = [];

        let infoView = 0;
        let infoWidth = 115;
        let infoHeight = 200;
        let infoTextureX = 0.0085;
        let infoTextureY = 0.005;
        let infoMesh;
        let fadeWidth = 1920;
        let fadeHeight = 1080;
        let fadeX = -960;
        let fadeY = -540;
        let fadeOpacity = 0.5;
        let fadeMesh;

        const loader = new THREE.TextureLoader();

        init();
        animate();

        function init() {
            //variable declarattions

            container = document.createElement('div');
            document.body.appendChild(container);

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f0f0);

            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 1000);
            camera.position.set(0, 150, 500);
            scene.add(camera);

            const light = new THREE.PointLight(0xffffff, 1);
            camera.add(light);

            group = new THREE.Group();
            group.position.y = 50;
            scene.add(group);

            loader.crossOrigin = "anonymous";

            const testShape = new THREE.Shape();
            roundedRect(testShape, 0, 0, 135, 220, 10);
            extrudeSettings = { depth: 0, bevelEnabled: false, bevelSegments: 2, steps: 2, bevelSize: 1, bevelThickness: 1 };

            /*
                --Spark Test:
            texture = loader.load("textures/sparkimage.png");
            texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(0.0062, 0.004);
            addShape(testShape, extrudeSettings, 0x008000, texture, -300, 0, 100, 0, 0, 0, 1);
            */

            //Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);

            //ThreeX domevents
            container.appendChild(renderer.domElement);
            container.style.touchAction = 'none';
            let domEvents = new THREEx.DomEvents(camera, renderer.domElement)

            // MELEE ROW
            roundedRect(rowShape, rowX, rowY, rowWidth, rowHeight, 10);
            extrudeSettings = { depth: 4, bevelEnabled: false, bevelSegments: 2, steps: 2, bevelSize: 1, bevelThickness: 1 };
            addShape(rowShape, extrudeSettings, 0x008000, null, -300, 0, 10, 0, 0, 0, 1);

            // Board Texture
            //texture = loader.load("textures/wood.jpg");
            //texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
            //texture.repeat.set(0.0012, 0.005);


            mesh.material.color = { "r": 232 / 255, "g": 218 / 255, "b": 125 / 255 };
            mesh.material.opacity = rowOpacity;
            meleeMesh = mesh;

            //domEvents.addEventListener(mesh, "mouseover", function (event) {
            //    mesh.material.opacity = 0.25;
            //});



            domEvents.addEventListener(mesh, "click", function (event) {
                if (selected && !melee.includes(selected) && selected["melee"]) {
                    handCards.splice(handCards.indexOf(selected), 1);

                    meleeMesh.material.opacity = rowOpacity;
                    rangedMesh.material.opacity = rowOpacity;
                    siegeMesh.material.opacity = rowOpacity;

                    selected["mesh"].scale.set(0.5, 0.5, 0.5)
                    melee.push(selected);
                    melee.sort(function (a, b) {
                        return -(b["strength"] - a["strength"]);
                    })
                    placesInRow(melee, meleeCardY);

                    selected = 0;

                    placeHand();
                }
            });

            //RANGED ROW
            addShape(rowShape, extrudeSettings, 0x008000, null, -300, - rowSpacing, 10, 0, 0, 0, 1);
            mesh.material.color = { "r": 232 / 255, "g": 218 / 255, "b": 125 / 255 };
            mesh.material.opacity = rowOpacity;
            rangedMesh = mesh;

            domEvents.addEventListener(mesh, "click", function (event) {
                if (selected && !ranged.includes(selected) && selected["ranged"]) {
                    handCards.splice(handCards.indexOf(selected), 1);

                    meleeMesh.material.opacity = rowOpacity;
                    rangedMesh.material.opacity = rowOpacity;
                    siegeMesh.material.opacity = rowOpacity;

                    selected["mesh"].scale.set(0.5, 0.5, 0.5)
                    ranged.push(selected);
                    ranged.sort(function (a, b) {
                        return -(b["strength"] - a["strength"]);
                    })
                    placesInRow(ranged, meleeCardY - cardVertSpacing);

                    selected = 0;

                    placeHand();
                }
            });

            //SEIGE ROW
            addShape(rowShape, extrudeSettings, 0x008000, null, -300, - 2 * rowSpacing, 10, 0, 0, 0, 1);
            mesh.material.color = { "r": 232 / 255, "g": 218 / 255, "b": 125 / 255 };
            mesh.material.opacity = rowOpacity;
            siegeMesh = mesh;

            domEvents.addEventListener(mesh, "click", function (event) {
                if (selected && !siege.includes(selected) && selected["siege"]) {
                    handCards.splice(handCards.indexOf(selected), 1);

                    meleeMesh.material.opacity = rowOpacity;
                    rangedMesh.material.opacity = rowOpacity;
                    siegeMesh.material.opacity = rowOpacity;

                    selected["mesh"].scale.set(0.5, 0.5, 0.5)
                    siege.push(selected);
                    siege.sort(function (a, b) {
                        return -(b["strength"] - a["strength"]);
                    })
                    placesInRow(siege, meleeCardY - 2 * cardVertSpacing);

                    selected = 0;

                    placeHand();
                }
            });

            function placesInRow(cards, cardY) {
                let positions = [];
                let placedCardWidth = cardWidth / 2;

                let placedCardX = 50;
                if (cards.length % 2 == 0)
                    placedCardX += placedCardWidth / 2;

                for (let i = 0; i < cards.length; i++) {
                    if (cards.length <= maxCards) {
                        if (i % 2 != 0)
                            positions[i] = placedCardX - (Math.floor(i / 2) + 1) * placedCardWidth;
                        else
                            positions[i] = placedCardX + (i / 2) * placedCardWidth;
                    }
                    else {
                        if (i % 2 != 0)
                            positions[i] = placedCardX - (Math.floor(i / 2) + 1) * (placedCardWidth - (cards.length - maxCards) / maxCards * placedCardWidth);
                        else
                            positions[i] = placedCardX + (i / 2) * (placedCardWidth - (cards.length - maxCards) / maxCards * placedCardWidth);
                    }
                }
                console.log(positions);
                positions.sort(function (a, b) {
                    return (a - b);
                });
                console.log(positions);

                for (let i = 0; i < cards.length; i++) {
                    cards[i]["mesh"].position.x = positions[i];
                    cards[i]["mesh"].position.y = cardY;
                    cards[i]["mesh"].position.z = i * 2 - 80;
                }
            }

            ///////
            //Card creation
            cardData.forEach(testDisplay);
            function testDisplay(d) {
                if (!d["leader"] && d["strength"] > 6
                    && x / 1000 < 1) {
                    const cardShape = new THREE.Shape();
                    roundedRect(cardShape, 0, 0, cardWidth, cardHeight, 10);
                    extrudeSettings = { depth: 4, bevelEnabled: false, bevelSegments: 2, steps: 2, bevelSize: 1, bevelThickness: 1 };

                    texture = loader.load(d["smallImage"]);

                    // it's necessary to apply these settings in order to correctly display the texture on a shape geometry

                    texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
                    texture.repeat.set(cardTextureX, cardTextureY);

                    addShape(cardShape, extrudeSettings, 0x008000, texture, 0, y, 0, 0, 0, 0, .9);

                    meshes.push(mesh);
                    let currentMesh = meshes.length - 1;

                    d["mesh"] = mesh;

                    domEvents.addEventListener(meshes[currentMesh], "mouseover", function (event) {
                        //ADD EVENT
                        if (!selected && !melee.includes(d) && !ranged.includes(d) && !siege.includes(d)) {
                            d["mesh"].position.z += 10;
                            d["mesh"].position.y += 20;
                        }
                    }, false);
                    domEvents.addEventListener(meshes[currentMesh], "mouseout", function (event) {
                        //ADD EVENT
                        if (!selected && !melee.includes(d) && !ranged.includes(d) && !siege.includes(d)) {
                            d["mesh"].position.z -= 10;
                            d["mesh"].position.y -= 20;
                        }
                    }, false);
                    domEvents.addEventListener(meshes[currentMesh], "click", function (event) {
                        if (!selected && !melee.includes(d) && !ranged.includes(d) && !siege.includes(d)) {
                            selected = d;
                            if (d["melee"])
                                meleeMesh.material.opacity = 0.3;
                            if (d["ranged"])
                                rangedMesh.material.opacity = 0.3;
                            if (d["siege"])
                                siegeMesh.material.opacity = 0.3;

                        } else if (selected == d) {
                            selected = 0;
                            meleeMesh.material.opacity = rowOpacity;
                            rangedMesh.material.opacity = rowOpacity;
                            siegeMesh.material.opacity = rowOpacity;
                        }
                    });
                    handCards[handCards.length] = d;


                    // it's necessary to apply these settings in order to correctly display the texture on a shape geometry

                    x += cardWidth;
                    if (x % 1000 == 0 && x != 0) {
                        y -= 100;
                        z = 0
                    }
                    z += 2;
                }
            }
            placeHand();

            function placeHand() {
                handCards.sort(function (a, b) {
                    return -(b["strength"] - a["strength"]);
                })
                let positions = [];
                console.log(handCards.length);
                if (handCards.length % 2 == 0)
                    handCardX = cardWidth / 2;
                for (let i = 0; i < handCards.length; i++) {
                    if (i % 2 != 0)
                        positions[i] = handCardX - (Math.floor(i / 2) + 1) * cardWidth;
                    else
                        positions[i] = handCardX + (i / 2) * cardWidth;
                }
                console.log(positions);
                positions.sort(function (a, b) {
                    return (a - b);
                });
                console.log(positions);
                let handZ = -140;
                for (let i = 0; i < handCards.length; i++) {
                    handCards[i]["mesh"].position.x = positions[i];
                    handCards[i]["mesh"].position.z = handZ;
                    handZ += 2;
                }
            }
            function placesInRow(cards, cardY) {
                let positions = [];
                let placedCardWidth = cardWidth / 2;

                let placedCardX = 50;
                if (cards.length % 2 == 0)
                    placedCardX += placedCardWidth / 2;

                for (let i = 0; i < cards.length; i++) {
                    if (cards.length <= maxCards) {
                        if (i % 2 != 0)
                            positions[i] = placedCardX - (Math.floor(i / 2) + 1) * placedCardWidth;
                        else
                            positions[i] = placedCardX + (i / 2) * placedCardWidth;
                    }
                    else {
                        if (i % 2 != 0)
                            positions[i] = placedCardX - (Math.floor(i / 2) + 1) * (placedCardWidth - (cards.length - maxCards) / maxCards * placedCardWidth);
                        else
                            positions[i] = placedCardX + (i / 2) * (placedCardWidth - (cards.length - maxCards) / maxCards * placedCardWidth);
                    }
                }
                positions.sort(function (a, b) {
                    return (a - b);
                });

                for (let i = 0; i < cards.length; i++) {
                    cards[i]["mesh"].position.x = positions[i];
                    cards[i]["mesh"].position.y = cardY;
                    cards[i]["mesh"].position.z = i * 2 - 80;
                }
            }


            const model_loader = new GLTFLoader();
            model_loader.load('./models/updated_gwent_board.glb', function (gltf) {
                var model = gltf.scene;
                console.log(model)
                model.position.set(-200.0, 0.0, -180.0)
                model.rotation.set(1.55, 0.0, 0.0);
                model.scale.set(0.95, 0.95, 0.95);
                scene.add(model);
            },

                undefined,

                function (error) {
                    console.error(error);
                });

        }



        function roundedRect(ctx, x, y, width, height, radius) {

            ctx.moveTo(x, y + radius);
            ctx.lineTo(x, y + height - radius);
            ctx.quadraticCurveTo(x, y + height, x + radius, y + height);
            ctx.lineTo(x + width - radius, y + height);
            ctx.quadraticCurveTo(x + width, y + height, x + width, y + height - radius);
            ctx.lineTo(x + width, y + radius);
            ctx.quadraticCurveTo(x + width, y, x + width - radius, y);
            ctx.lineTo(x + radius, y);
            ctx.quadraticCurveTo(x, y, x, y + radius);

        }

        function addShape(shape, extrudeSettings, color, texture, x, y, z, rx, ry, rz, s) {

            // console.log(texture);
            const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);

            mesh = new THREE.Mesh(geometry, new THREE.MeshPhongMaterial({ map: texture, transparent: true }));

            mesh.position.set(x, y, z - 75);
            mesh.rotation.set(rx, ry, rz);
            mesh.scale.set(s, s, s);
            group.add(mesh);
        }

        function animate() {

            requestAnimationFrame(animate);

            render();
        }

        function render() {

            group.rotation.y += (targetRotation - group.rotation.y) * 0.05;
            renderer.render(scene, camera);
        }

        renderer.domElement.addEventListener("click", onclick, true);

        document.addEventListener("keypress", function (event) {
            if (event.keyCode == 99) {
                if (selected) {
                    if (infoView) {
                        infoView = 0;
                        group.remove(infoMesh);
                        group.remove(fadeMesh);
                    }
                    else {
                        infoView = 1;
                        const infoShape = new THREE.Shape();
                        roundedRect(infoShape, 0, 0, infoWidth, infoHeight, 10);
                        extrudeSettings = { depth: 4, bevelEnabled: false, bevelSegments: 2, steps: 2, bevelSize: 1, bevelThickness: 1 };

                        texture = loader.load(selected["image"]);

                        // it's necessary to apply these settings in order to correctly display the texture on a shape geometry

                        texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
                        texture.repeat.set(infoTextureX, infoTextureY);

                        addShape(infoShape, extrudeSettings, 0x008000, texture, -infoWidth / 2 + 10, 0, 200, 0, 0, 0, 1.1);
                        infoMesh = mesh;

                        const fadeShape = new THREE.Shape();
                        roundedRect(fadeShape, 0, 0, fadeWidth, fadeHeight, 10);
                        extrudeSettings = {};
                        addShape(fadeShape, extrudeSettings, 0xffffff, null, fadeX, fadeY, 100, 0, 0, 0, .9);
                        mesh.material.opacity = fadeOpacity;
                        fadeMesh = mesh;

                        if (selected['audio'] != 0) {
                            selected['audio'].play();
                            selected['audio'].currentTime = 0;
                        }
                    }
                }
            }
        });

        /////
        function makeTHREEx() {
            // # Constructor
            THREEx.DomEvents = function (camera, domElement) {
                this._camera = camera || null;
                this._domElement = domElement || document;
                this._raycaster = new THREE.Raycaster();
                this._selected = null;
                this._boundObjs = {};
                // Bind dom event for mouse and touch
                var _this = this;

                this._$onClick = function () { _this._onClick.apply(_this, arguments); };
                this._$onDblClick = function () { _this._onDblClick.apply(_this, arguments); };
                this._$onMouseMove = function () { _this._onMouseMove.apply(_this, arguments); };
                this._$onMouseDown = function () { _this._onMouseDown.apply(_this, arguments); };
                this._$onMouseUp = function () { _this._onMouseUp.apply(_this, arguments); };
                this._$onTouchMove = function () { _this._onTouchMove.apply(_this, arguments); };
                this._$onTouchStart = function () { _this._onTouchStart.apply(_this, arguments); };
                this._$onTouchEnd = function () { _this._onTouchEnd.apply(_this, arguments); };
                this._$onContextmenu = function () { _this._onContextmenu.apply(_this, arguments); };
                this._domElement.addEventListener('click', this._$onClick, false);
                this._domElement.addEventListener('dblclick', this._$onDblClick, false);
                this._domElement.addEventListener('mousemove', this._$onMouseMove, false);
                this._domElement.addEventListener('mousedown', this._$onMouseDown, false);
                this._domElement.addEventListener('mouseup', this._$onMouseUp, false);
                this._domElement.addEventListener('touchmove', this._$onTouchMove, false);
                this._domElement.addEventListener('touchstart', this._$onTouchStart, false);
                this._domElement.addEventListener('touchend', this._$onTouchEnd, false);
                this._domElement.addEventListener('contextmenu', this._$onContextmenu, false);

            }

            // # Destructor
            THREEx.DomEvents.prototype.destroy = function () {
                // unBind dom event for mouse and touch
                this._domElement.removeEventListener('click', this._$onClick, false);
                this._domElement.removeEventListener('dblclick', this._$onDblClick, false);
                this._domElement.removeEventListener('mousemove', this._$onMouseMove, false);
                this._domElement.removeEventListener('mousedown', this._$onMouseDown, false);
                this._domElement.removeEventListener('mouseup', this._$onMouseUp, false);
                this._domElement.removeEventListener('touchmove', this._$onTouchMove, false);
                this._domElement.removeEventListener('touchstart', this._$onTouchStart, false);
                this._domElement.removeEventListener('touchend', this._$onTouchEnd, false);
                this._domElement.removeEventListener('contextmenu', this._$onContextmenu, false);
            }

            THREEx.DomEvents.eventNames = [
                "click",
                "dblclick",
                "mouseover",
                "mouseout",
                "mousemove",
                "mousedown",
                "mouseup",
                "contextmenu",
                "touchstart",
                "touchend"
            ];

            THREEx.DomEvents.prototype._getRelativeMouseXY = function (domEvent) {
                var element = domEvent.target || domEvent.srcElement;
                if (element.nodeType === 3) {
                    element = element.parentNode; // Safari fix -- see http://www.quirksmode.org/js/events_properties.html
                }

                //get the real position of an element relative to the page starting point (0, 0)
                //credits go to brainjam on answering http://stackoverflow.com/questions/5755312/getting-mouse-position-relative-to-content-area-of-an-element
                var elPosition = { x: 0, y: 0 };
                var tmpElement = element;
                //store padding
                var style = getComputedStyle(tmpElement, null);
                elPosition.y += parseInt(style.getPropertyValue("padding-top"), 10);
                elPosition.x += parseInt(style.getPropertyValue("padding-left"), 10);
                //add positions
                do {
                    elPosition.x += tmpElement.offsetLeft;
                    elPosition.y += tmpElement.offsetTop;
                    style = getComputedStyle(tmpElement, null);

                    elPosition.x += parseInt(style.getPropertyValue("border-left-width"), 10);
                    elPosition.y += parseInt(style.getPropertyValue("border-top-width"), 10);
                } while (tmpElement = tmpElement.offsetParent);

                var elDimension = {
                    width: (element === window) ? window.innerWidth : element.offsetWidth,
                    height: (element === window) ? window.innerHeight : element.offsetHeight
                };

                return {
                    x: +((domEvent.pageX - elPosition.x) / elDimension.width) * 2 - 1,
                    y: -((domEvent.pageY - elPosition.y) / elDimension.height) * 2 + 1
                };
            };


            /********************************************************************************/
            /*		domevent context						*/
            /********************************************************************************/

            // handle domevent context in object3d instance

            THREEx.DomEvents.prototype._objectCtxInit = function (object3d) {
                object3d._3xDomEvent = {};
            }
            THREEx.DomEvents.prototype._objectCtxDeinit = function (object3d) {
                delete object3d._3xDomEvent;
            }
            THREEx.DomEvents.prototype._objectCtxIsInit = function (object3d) {
                return object3d._3xDomEvent ? true : false;
            }
            THREEx.DomEvents.prototype._objectCtxGet = function (object3d) {
                return object3d._3xDomEvent;
            }

            /********************************************************************************/
            /*										*/
            /********************************************************************************/

            /**
             * Getter/Setter for camera
            */
            THREEx.DomEvents.prototype.camera = function (value) {
                if (value) this._camera = value;
                return this._camera;
            }

            THREEx.DomEvents.prototype.bind = function (object3d, eventName, callback, useCapture) {
                console.assert(THREEx.DomEvents.eventNames.indexOf(eventName) !== -1, "not available events:" + eventName);

                if (!this._objectCtxIsInit(object3d)) this._objectCtxInit(object3d);
                var objectCtx = this._objectCtxGet(object3d);
                if (!objectCtx[eventName + 'Handlers']) objectCtx[eventName + 'Handlers'] = [];

                objectCtx[eventName + 'Handlers'].push({
                    callback: callback,
                    useCapture: useCapture
                });

                // add this object in this._boundObjs
                if (this._boundObjs[eventName] === undefined) {
                    this._boundObjs[eventName] = [];
                }
                this._boundObjs[eventName].push(object3d);
            }
            THREEx.DomEvents.prototype.addEventListener = THREEx.DomEvents.prototype.bind

            THREEx.DomEvents.prototype.unbind = function (object3d, eventName, callback, useCapture) {
                console.assert(THREEx.DomEvents.eventNames.indexOf(eventName) !== -1, "not available events:" + eventName);

                if (!this._objectCtxIsInit(object3d)) this._objectCtxInit(object3d);

                var objectCtx = this._objectCtxGet(object3d);
                if (!objectCtx[eventName + 'Handlers']) objectCtx[eventName + 'Handlers'] = [];

                var handlers = objectCtx[eventName + 'Handlers'];
                for (var i = 0; i < handlers.length; i++) {
                    var handler = handlers[i];
                    if (callback != handler.callback) continue;
                    if (useCapture != handler.useCapture) continue;
                    handlers.splice(i, 1)
                    break;
                }
                // from this object from this._boundObjs
                var index = this._boundObjs[eventName].indexOf(object3d);
                console.assert(index !== -1);
                this._boundObjs[eventName].splice(index, 1);
            }
            THREEx.DomEvents.prototype.removeEventListener = THREEx.DomEvents.prototype.unbind

            THREEx.DomEvents.prototype._bound = function (eventName, object3d) {
                var objectCtx = this._objectCtxGet(object3d);
                if (!objectCtx) return false;
                return objectCtx[eventName + 'Handlers'] ? true : false;
            }

            /********************************************************************************/
            /*		onMove								*/
            /********************************************************************************/

            // # handle mousemove kind of events

            THREEx.DomEvents.prototype._onMove = function (eventName, mouseX, mouseY, origDomEvent) {
                //console.log('eventName', eventName, 'boundObjs', this._boundObjs[eventName])
                // get objects bound to this event
                var boundObjs = this._boundObjs[eventName];
                if (boundObjs === undefined || boundObjs.length === 0) return;
                // compute the intersection
                var vector = new THREE.Vector2();

                // update the picking ray with the camera and mouse position
                vector.set(mouseX, mouseY);
                this._raycaster.setFromCamera(vector, this._camera);

                var intersects = this._raycaster.intersectObjects(boundObjs);

                var oldSelected = this._selected;

                if (intersects.length > 0) {
                    var notifyOver, notifyOut, notifyMove;
                    var intersect = intersects[0];
                    var newSelected = intersect.object;
                    this._selected = newSelected;
                    // if newSelected bound mousemove, notify it
                    notifyMove = this._bound('mousemove', newSelected);

                    if (oldSelected != newSelected) {
                        // if newSelected bound mouseenter, notify it
                        notifyOver = this._bound('mouseover', newSelected);
                        // if there is a oldSelect and oldSelected bound mouseleave, notify it
                        notifyOut = oldSelected && this._bound('mouseout', oldSelected);
                    }
                } else {
                    // if there is a oldSelect and oldSelected bound mouseleave, notify it
                    notifyOut = oldSelected && this._bound('mouseout', oldSelected);
                    this._selected = null;
                }


                // notify mouseMove - done at the end with a copy of the list to allow callback to remove handlers
                notifyMove && this._notify('mousemove', newSelected, origDomEvent, intersect);
                // notify mouseEnter - done at the end with a copy of the list to allow callback to remove handlers
                notifyOver && this._notify('mouseover', newSelected, origDomEvent, intersect);
                // notify mouseLeave - done at the end with a copy of the list to allow callback to remove handlers
                notifyOut && this._notify('mouseout', oldSelected, origDomEvent, intersect);
            }


            /********************************************************************************/
            /*		onEvent								*/
            /********************************************************************************/

            // # handle click kind of events

            THREEx.DomEvents.prototype._onEvent = function (eventName, mouseX, mouseY, origDomEvent) {
                //console.log('eventName', eventName, 'boundObjs', this._boundObjs[eventName])
                // get objects bound to this event
                var boundObjs = this._boundObjs[eventName];
                if (boundObjs === undefined || boundObjs.length === 0) return;
                // compute the intersection
                var vector = new THREE.Vector2();

                // update the picking ray with the camera and mouse position
                vector.set(mouseX, mouseY);
                this._raycaster.setFromCamera(vector, this._camera);

                var intersects = this._raycaster.intersectObjects(boundObjs, true);
                // if there are no intersections, return now
                if (intersects.length === 0) return;

                // init some variables
                var intersect = intersects[0];
                var object3d = intersect.object;
                var objectCtx = this._objectCtxGet(object3d);
                var objectParent = object3d.parent;

                while (typeof (objectCtx) == 'undefined' && objectParent) {
                    objectCtx = this._objectCtxGet(objectParent);
                    objectParent = objectParent.parent;
                }
                if (!objectCtx) return;

                // notify handlers
                this._notify(eventName, object3d, origDomEvent, intersect);
            }

            THREEx.DomEvents.prototype._notify = function (eventName, object3d, origDomEvent, intersect) {
                var objectCtx = this._objectCtxGet(object3d);
                var handlers = objectCtx ? objectCtx[eventName + 'Handlers'] : null;

                // parameter check
                console.assert(arguments.length === 4)

                // do bubbling
                if (!objectCtx || !handlers || handlers.length === 0) {
                    object3d.parent && this._notify(eventName, object3d.parent, origDomEvent, intersect);
                    return;
                }

                // notify all handlers
                var handlers = objectCtx[eventName + 'Handlers'];
                for (var i = 0; i < handlers.length; i++) {
                    var handler = handlers[i];
                    var toPropagate = true;
                    handler.callback({
                        type: eventName,
                        target: object3d,
                        origDomEvent: origDomEvent,
                        intersect: intersect,
                        stopPropagation: function () {
                            toPropagate = false;
                        }
                    });
                    if (!toPropagate) continue;
                    // do bubbling
                    if (handler.useCapture === false) {
                        object3d.parent && this._notify(eventName, object3d.parent, origDomEvent, intersect);
                    }
                }
            }

            /********************************************************************************/
            /*		handle mouse events						*/
            /********************************************************************************/
            // # handle mouse events

            THREEx.DomEvents.prototype._onMouseDown = function (event) { return this._onMouseEvent('mousedown', event); }
            THREEx.DomEvents.prototype._onMouseUp = function (event) { return this._onMouseEvent('mouseup', event); }


            THREEx.DomEvents.prototype._onMouseEvent = function (eventName, domEvent) {
                var mouseCoords = this._getRelativeMouseXY(domEvent);
                this._onEvent(eventName, mouseCoords.x, mouseCoords.y, domEvent);
            }

            THREEx.DomEvents.prototype._onMouseMove = function (domEvent) {
                var mouseCoords = this._getRelativeMouseXY(domEvent);
                this._onMove('mousemove', mouseCoords.x, mouseCoords.y, domEvent);
                this._onMove('mouseover', mouseCoords.x, mouseCoords.y, domEvent);
                this._onMove('mouseout', mouseCoords.x, mouseCoords.y, domEvent);
            }

            THREEx.DomEvents.prototype._onClick = function (event) {
                // TODO handle touch ?
                this._onMouseEvent('click', event);
            }
            THREEx.DomEvents.prototype._onDblClick = function (event) {
                // TODO handle touch ?
                this._onMouseEvent('dblclick', event);
            }

            THREEx.DomEvents.prototype._onContextmenu = function (event) {
                //TODO don't have a clue about how this should work with touch..
                this._onMouseEvent('contextmenu', event);
            }

            /********************************************************************************/
            /*		handle touch events						*/
            /********************************************************************************/
            // # handle touch events


            THREEx.DomEvents.prototype._onTouchStart = function (event) { return this._onTouchEvent('touchstart', event); }
            THREEx.DomEvents.prototype._onTouchEnd = function (event) { return this._onTouchEvent('touchend', event); }

            THREEx.DomEvents.prototype._onTouchMove = function (domEvent) {
                if (domEvent.touches.length != 1) return undefined;

                domEvent.preventDefault();

                var mouseX = +(domEvent.touches[0].pageX / window.innerWidth) * 2 - 1;
                var mouseY = -(domEvent.touches[0].pageY / window.innerHeight) * 2 + 1;
                this._onMove('mousemove', mouseX, mouseY, domEvent);
                this._onMove('mouseover', mouseX, mouseY, domEvent);
                this._onMove('mouseout', mouseX, mouseY, domEvent);
            }

            THREEx.DomEvents.prototype._onTouchEvent = function (eventName, domEvent) {
                if (domEvent.touches.length != 1) return undefined;

                domEvent.preventDefault();

                var mouseX = +(domEvent.touches[0].pageX / window.innerWidth) * 2 - 1;
                var mouseY = -(domEvent.touches[0].pageY / window.innerHeight) * 2 + 1;
                this._onEvent(eventName, mouseX, mouseY, domEvent);
            }
            //
        }



        /////
    </script>
    <p></p>
</body>

</html>